package deploy

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// RollbackConfig holds parameters for generating a rollback plan.
type RollbackConfig struct {
	// BackupDir is the directory containing the previous deployment backup.
	BackupDir string

	// PreviousVersion is the version to roll back to.
	PreviousVersion string

	// Host is the hostname being rolled back.
	Host string
}

// dpDetectPreviousVersion reads the version from a cached metadata file
// in the given cache directory.
func dpDetectPreviousVersion(cacheDir string) (string, error) {
	versionFile := filepath.Join(cacheDir, "version")
	data, err := os.ReadFile(versionFile)
	if err != nil {
		return "", fmt.Errorf("deploy: read version file: %w", err)
	}
	version := strings.TrimSpace(string(data))
	if version == "" {
		return "", fmt.Errorf("deploy: version file is empty: %s", versionFile)
	}
	return version, nil
}

// dpCreateRollbackPlan generates an ordered list of human-readable rollback
// steps based on the configuration.
func dpCreateRollbackPlan(config *RollbackConfig) ([]string, error) {
	if config == nil {
		return nil, fmt.Errorf("deploy: nil rollback config")
	}
	if config.BackupDir == "" {
		return nil, fmt.Errorf("deploy: backup directory not specified")
	}
	if config.PreviousVersion == "" {
		return nil, fmt.Errorf("deploy: previous version not specified")
	}
	if config.Host == "" {
		return nil, fmt.Errorf("deploy: host not specified")
	}

	steps := []string{
		fmt.Sprintf("Stop prompt-pulse daemon on %s", config.Host),
		fmt.Sprintf("Back up current deployment to %s/current-backup", config.BackupDir),
		fmt.Sprintf("Restore prompt-pulse %s from %s", config.PreviousVersion, config.BackupDir),
		fmt.Sprintf("Restore configuration from %s/config", config.BackupDir),
		fmt.Sprintf("Restore cache from %s/cache", config.BackupDir),
		fmt.Sprintf("Restart prompt-pulse daemon on %s", config.Host),
		fmt.Sprintf("Verify rollback: run deployment checks on %s", config.Host),
	}
	return steps, nil
}

// dpValidateBackup verifies that a backup directory exists and contains
// the expected structure (binary, config, cache subdirectories).
func dpValidateBackup(backupDir string) error {
	info, err := os.Stat(backupDir)
	if err != nil {
		return fmt.Errorf("deploy: backup dir not found: %w", err)
	}
	if !info.IsDir() {
		return fmt.Errorf("deploy: backup path is not a directory: %s", backupDir)
	}

	required := []string{"binary", "config", "cache"}
	for _, sub := range required {
		p := filepath.Join(backupDir, sub)
		if _, err := os.Stat(p); err != nil {
			return fmt.Errorf("deploy: backup missing %s: %s", sub, p)
		}
	}
	return nil
}

const rollbackScriptTmpl = `#!/usr/bin/env bash
# Rollback script for prompt-pulse on {{.Host}}
# Rolling back to version {{.PreviousVersion}}
# Generated by prompt-pulse deploy verification
#
# Review this script before executing. It is safe to run manually.
set -euo pipefail

BACKUP_DIR="{{.BackupDir}}"
HOST="{{.Host}}"
VERSION="{{.PreviousVersion}}"

echo "Rolling back prompt-pulse to ${VERSION} on ${HOST}..."

# Step 1: Stop the daemon
echo "[1/5] Stopping daemon..."
if [ -S /tmp/prompt-pulse.sock ]; then
  prompt-pulse daemon stop 2>/dev/null || true
fi
sleep 1

# Step 2: Backup current deployment
echo "[2/5] Backing up current deployment..."
CURRENT_BACKUP="${BACKUP_DIR}/pre-rollback-$(date +%Y%m%d%H%M%S)"
mkdir -p "${CURRENT_BACKUP}"
cp -a ~/.local/bin/prompt-pulse "${CURRENT_BACKUP}/binary" 2>/dev/null || true
cp -a ~/.config/prompt-pulse "${CURRENT_BACKUP}/config" 2>/dev/null || true

# Step 3: Restore binary
echo "[3/5] Restoring binary..."
cp -a "${BACKUP_DIR}/binary" ~/.local/bin/prompt-pulse
chmod +x ~/.local/bin/prompt-pulse

# Step 4: Restore configuration
echo "[4/5] Restoring configuration..."
cp -a "${BACKUP_DIR}/config" ~/.config/prompt-pulse

# Step 5: Restart daemon
echo "[5/5] Restarting daemon..."
prompt-pulse daemon start

echo "Rollback to ${VERSION} complete. Run 'prompt-pulse verify' to check."
`

// dpGenerateRollbackScript produces a reviewable shell script that
// performs a manual rollback using the given configuration.
func dpGenerateRollbackScript(config *RollbackConfig) (string, error) {
	if config == nil {
		return "", fmt.Errorf("deploy: nil rollback config")
	}
	if config.BackupDir == "" {
		return "", fmt.Errorf("deploy: backup directory not specified")
	}
	if config.PreviousVersion == "" {
		return "", fmt.Errorf("deploy: previous version not specified")
	}
	if config.Host == "" {
		return "", fmt.Errorf("deploy: host not specified")
	}

	tmpl, err := template.New("rollback").Parse(rollbackScriptTmpl)
	if err != nil {
		return "", fmt.Errorf("deploy: parse template: %w", err)
	}

	var b strings.Builder
	if err := tmpl.Execute(&b, config); err != nil {
		return "", fmt.Errorf("deploy: execute template: %w", err)
	}
	return b.String(), nil
}
